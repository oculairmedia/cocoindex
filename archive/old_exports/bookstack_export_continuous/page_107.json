{
  "id": 107,
  "title": "Mode Selection & Configuration Updates",
  "slug": "mode-selection-configuration-updates",
  "url": "https://knowledge.oculair.ca/books/unknown/page/mode-selection-configuration-updates",
  "updated_at": "2025-05-01T19:31:25.000000Z",
  "body_html": "<h1 id=\"bkmrk-mode-selection-%26-con\">Mode Selection &amp; Configuration Updates</h1>\n<p id=\"bkmrk-this-page-covers-the\">This page covers the core logic for analyzing conversations, selecting appropriate modes, and applying configuration updates to agents.</p>\n<h2 id=\"bkmrk-conversation-analysi\">Conversation Analysis</h2>\n<p id=\"bkmrk-the-first-step-in-th\">The first step in the Meta-Agent's workflow is to analyze recent conversations to determine if a mode change is warranted:</p>\n<pre id=\"bkmrk-def-analyze_conversa\"><code class=\"language-python\">def analyze_conversation(agent_id, meta_agent_id):\n    \"\"\"Analyze recent conversations for an agent to determine if a mode change is needed\"\"\"\n    \n    # Get tracking data to find the last checked message\n    tracking_data = get_tracking_data(meta_agent_id)\n    last_checked_message_id = tracking_data.get(\"last_check_timestamps\", {}).get(agent_id)\n    \n    # Fetch recent messages\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    params = {}\n    if last_checked_message_id:\n        params[\"after\"] = last_checked_message_id\n    \n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{agent_id}/messages\",\n        headers=headers,\n        params=params\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to fetch messages for agent {agent_id}\")\n        return None, None\n    \n    messages = response.json()\n    \n    if not messages:\n        print(f\"No new messages for agent {agent_id}\")\n        return None, None\n    \n    # Update last checked message ID\n    last_message_id = messages[-1][\"id\"]\n    update_last_checked_message(meta_agent_id, agent_id, last_message_id)\n    \n    # Extract conversation features\n    conversation_text = \" \".join([msg.get(\"content\", \"\") for msg in messages if msg.get(\"role\") == \"user\"])\n    \n    # Get current mode\n    current_mode = tracking_data[\"monitored_agents\"][agent_id][\"current_mode\"]\n    \n    # Analyze the conversation\n    analysis = {\n        \"message_count\": len(messages),\n        \"explicit_mode_requests\": detect_explicit_mode_requests(conversation_text),\n        \"detected_patterns\": detect_conversation_patterns(conversation_text),\n        \"conversation_complexity\": calculate_complexity(conversation_text),\n        \"current_mode\": current_mode\n    }\n    \n    return analysis, messages\n\ndef detect_explicit_mode_requests(text):\n    \"\"\"Detect explicit requests to change modes\"\"\"\n    explicit_requests = []\n    \n    # Define patterns for explicit mode requests\n    mode_request_patterns = {\n        \"analytical\": [\n            r\"(?i)switch\\s+to\\s+analytical\\s+mode\",\n            r\"(?i)use\\s+analytical\\s+mode\",\n            r\"(?i)change\\s+to\\s+analysis\\s+mode\"\n        ],\n        \"creative\": [\n            r\"(?i)switch\\s+to\\s+creative\\s+mode\",\n            r\"(?i)use\\s+creative\\s+mode\",\n            r\"(?i)change\\s+to\\s+brainstorming\\s+mode\"\n        ],\n        \"educational\": [\n            r\"(?i)switch\\s+to\\s+educational\\s+mode\",\n            r\"(?i)use\\s+teaching\\s+mode\",\n            r\"(?i)change\\s+to\\s+explanation\\s+mode\"\n        ]\n    }\n    \n    # Check for matches\n    for mode, patterns in mode_request_patterns.items():\n        for pattern in patterns:\n            if re.search(pattern, text):\n                explicit_requests.append(mode)\n                break\n    \n    return explicit_requests\n\ndef detect_conversation_patterns(text):\n    \"\"\"Detect patterns that suggest particular modes\"\"\"\n    patterns = {\n        \"analytical\": 0,\n        \"creative\": 0,\n        \"educational\": 0\n    }\n    \n    # Define indicator words for each mode\n    indicators = {\n        \"analytical\": [\n            \"analyze\", \"examine\", \"compare\", \"evaluate\", \"research\",\n            \"investigate\", \"data\", \"evidence\", \"conclusion\", \"pros and cons\"\n        ],\n        \"creative\": [\n            \"brainstorm\", \"imagine\", \"create\", \"design\", \"invent\",\n            \"idea\", \"creative\", \"innovative\", \"novel\", \"unique\"\n        ],\n        \"educational\": [\n            \"explain\", \"teach\", \"learn\", \"understand\", \"tutorial\",\n            \"how does\", \"what is\", \"why does\", \"concept\", \"example\"\n        ]\n    }\n    \n    # Count occurrences of indicator words\n    text_lower = text.lower()\n    for mode, words in indicators.items():\n        for word in words:\n            patterns[mode] += len(re.findall(r\"\\b\" + word + r\"\\b\", text_lower))\n    \n    return patterns\n\ndef calculate_complexity(text):\n    \"\"\"Calculate the complexity of the conversation\"\"\"\n    # Simple complexity heuristic based on sentence length and vocabulary\n    sentences = re.split(r\"[.!?]\", text)\n    avg_sentence_length = sum(len(s.split()) for s in sentences) / max(len(sentences), 1)\n    \n    # Count unique words as a measure of vocabulary complexity\n    words = re.findall(r\"\\b\\w+\\b\", text.lower())\n    unique_words = len(set(words))\n    \n    # Calculate complexity score (0-100)\n    complexity = min(100, (avg_sentence_length * 5) + (unique_words / 10))\n    \n    return complexity\n</code></pre>\n<h2 id=\"bkmrk-mode-selection-logic\">Mode Selection Logic</h2>\n<p id=\"bkmrk-once-the-conversatio\">Once the conversation has been analyzed, the Meta-Agent needs to determine if a mode change is appropriate and which mode to select:</p>\n<pre id=\"bkmrk-def-select_optimal_m\"><code class=\"language-python\">def select_optimal_mode(analysis, available_modes):\n    \"\"\"Select the optimal mode based on conversation analysis\"\"\"\n    \n    # Check for explicit mode requests first\n    if analysis[\"explicit_mode_requests\"]:\n        requested_mode = analysis[\"explicit_mode_requests\"][0]  # Take the first request if multiple\n        print(f\"Explicit mode request detected: {requested_mode}\")\n        return requested_mode\n    \n    # Otherwise, use pattern-based selection\n    patterns = analysis[\"detected_patterns\"]\n    current_mode = analysis[\"current_mode\"]\n    \n    # Find the mode with the highest pattern score\n    highest_score = 0\n    best_mode = current_mode  # Default to current mode\n    \n    for mode, score in patterns.items():\n        if score &gt; highest_score:\n            highest_score = score\n            best_mode = mode\n    \n    # Only change mode if the score difference is significant\n    # This prevents thrashing between modes\n    if best_mode != current_mode:\n        current_score = patterns.get(current_mode, 0)\n        if highest_score &gt; current_score * 1.5 and highest_score &gt;= 3:\n            print(f\"Pattern-based mode change: {current_mode} -&gt; {best_mode} (score: {highest_score})\")\n            return best_mode\n    \n    # Consider complexity-based mode selection\n    complexity = analysis[\"conversation_complexity\"]\n    if complexity &gt; 80 and current_mode != \"analytical\":\n        print(f\"Complexity-based mode change: {current_mode} -&gt; analytical (complexity: {complexity})\")\n        return \"analytical\"\n    elif 40 &lt;= complexity &lt;= 80 and current_mode == \"analytical\":\n        print(f\"Complexity-based mode change: {current_mode} -&gt; educational (complexity: {complexity})\")\n        return \"educational\"\n    \n    # No change needed\n    return current_mode\n</code></pre>\n<h2 id=\"bkmrk-configuration-update\">Configuration Updates</h2>\n<p id=\"bkmrk-once-a-mode-has-been\">Once a mode has been selected, the Meta-Agent applies the corresponding configuration updates to the target agent:</p>\n<pre id=\"bkmrk-def-apply_mode_confi\"><code class=\"language-python\">def apply_mode_configuration(agent_id, meta_agent_id, mode_id):\n    \"\"\"Apply mode-specific configuration to an agent\"\"\"\n    \n    # Get the detailed mode configuration\n    mode_config = get_mode_configuration(meta_agent_id, mode_id)\n    if not mode_config:\n        print(f\"Mode configuration not found for: {mode_id}\")\n        return False\n    \n    # Apply persona adjustments if specified\n    if \"persona_adjustments\" in mode_config:\n        apply_persona_adjustments(agent_id, mode_config[\"persona_adjustments\"])\n    \n    # Apply tool preferences if specified\n    if \"tool_preferences\" in mode_config:\n        apply_tool_preferences(agent_id, mode_config[\"tool_preferences\"])\n    \n    # Apply memory priorities if specified\n    if \"memory_priorities\" in mode_config:\n        apply_memory_priorities(agent_id, mode_config[\"memory_priorities\"])\n    \n    # Update tracking data\n    update_mode_tracking(meta_agent_id, agent_id, mode_id)\n    \n    # Notify the agent of the mode change\n    notify_agent_of_mode_change(meta_agent_id, agent_id, mode_id, mode_config[\"name\"], mode_config[\"description\"])\n    \n    return True\n\ndef get_mode_configuration(meta_agent_id, mode_id):\n    \"\"\"Retrieve the detailed configuration for a specific mode\"\"\"\n    \n    # First check the core memory for basic mode info\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/modes_repository\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to retrieve modes repository\")\n        return None\n    \n    modes_repo = json.loads(response.json()[\"content\"])\n    basic_mode_info = None\n    \n    for mode in modes_repo[\"available_modes\"]:\n        if mode[\"mode_id\"] == mode_id:\n            basic_mode_info = mode\n            break\n    \n    if not basic_mode_info:\n        print(f\"Mode {mode_id} not found in repository\")\n        return None\n    \n    # Now search archival memory for detailed configuration\n    response = requests.post(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/archival-memory/search\",\n        headers=headers,\n        json={\"query\": f\"Mode Definition: {mode_id}\"}\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to search archival memory for mode {mode_id}\")\n        return basic_mode_info  # Return basic info if detailed not found\n    \n    search_results = response.json()\n    if not search_results:\n        return basic_mode_info  # Return basic info if detailed not found\n    \n    # Parse the detailed mode definition from archival memory\n    for result in search_results:\n        content = result.get(\"content\", \"\")\n        if f\"Mode Definition: \" in content and mode_id in content:\n            # Extract the JSON part\n            json_str = content.split(\"Mode Definition: \", 1)[1]\n            try:\n                detailed_config = json.loads(json_str)\n                return detailed_config\n            except json.JSONDecodeError:\n                print(f\"Failed to parse mode configuration for {mode_id}\")\n    \n    return basic_mode_info  # Fallback to basic info\n\ndef apply_persona_adjustments(agent_id, persona_adjustments):\n    \"\"\"Apply persona adjustments to an agent\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get current persona\n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{agent_id}/core-memory/persona\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to retrieve persona for agent {agent_id}\")\n        return False\n    \n    persona = response.json()[\"content\"]\n    \n    # Apply replacements\n    if \"replace\" in persona_adjustments:\n        for replacement in persona_adjustments[\"replace\"]:\n            if \"old\" in replacement and \"new\" in replacement:\n                persona = persona.replace(replacement[\"old\"], replacement[\"new\"])\n    \n    # Append additions\n    if \"append\" in persona_adjustments and persona_adjustments[\"append\"]:\n        # Check if the append text is already in the persona to avoid duplication\n        if persona_adjustments[\"append\"] not in persona:\n            persona += \"\\n\" + persona_adjustments[\"append\"]\n    \n    # Update persona\n    response = requests.put(\n        f\"{LETTA_API_BASE}/agents/{agent_id}/core-memory/persona\",\n        headers=headers,\n        json={\"content\": persona}\n    )\n    \n    if response.status_code == 200:\n        print(f\"Persona adjustments applied to agent {agent_id}\")\n        return True\n    else:\n        print(f\"Failed to apply persona adjustments to agent {agent_id}\")\n        return False\n\ndef apply_tool_preferences(agent_id, tool_preferences):\n    \"\"\"Apply tool preferences to an agent\"\"\"\n    \n    # This would involve updating the agent's tool configuration\n    # The exact implementation depends on how tools are managed in your system\n    \n    # For example, you might update the agent's configuration to prioritize certain tools\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get current agent configuration\n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{agent_id}\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to retrieve configuration for agent {agent_id}\")\n        return False\n    \n    agent_config = response.json()\n    \n    # Update tool preferences in metadata\n    if \"metadata\" not in agent_config:\n        agent_config[\"metadata\"] = {}\n    \n    agent_config[\"metadata\"][\"tool_preferences\"] = tool_preferences\n    \n    # Update agent configuration\n    response = requests.patch(\n        f\"{LETTA_API_BASE}/agents/{agent_id}\",\n        headers=headers,\n        json={\"metadata\": agent_config[\"metadata\"]}\n    )\n    \n    if response.status_code == 200:\n        print(f\"Tool preferences applied to agent {agent_id}\")\n        return True\n    else:\n        print(f\"Failed to apply tool preferences to agent {agent_id}\")\n        return False\n\ndef apply_memory_priorities(agent_id, memory_priorities):\n    \"\"\"Apply memory priorities to an agent\"\"\"\n    \n    # This would involve updating the agent's memory configuration\n    # The exact implementation depends on how memory is managed in your system\n    \n    # For example, you might update the agent's system prompt to include memory priority instructions\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get current agent configuration\n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{agent_id}\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to retrieve configuration for agent {agent_id}\")\n        return False\n    \n    agent_config = response.json()\n    \n    # Update memory priorities in metadata\n    if \"metadata\" not in agent_config:\n        agent_config[\"metadata\"] = {}\n    \n    agent_config[\"metadata\"][\"memory_priorities\"] = memory_priorities\n    \n    # Update agent configuration\n    response = requests.patch(\n        f\"{LETTA_API_BASE}/agents/{agent_id}\",\n        headers=headers,\n        json={\"metadata\": agent_config[\"metadata\"]}\n    )\n    \n    if response.status_code == 200:\n        print(f\"Memory priorities applied to agent {agent_id}\")\n        return True\n    else:\n        print(f\"Failed to apply memory priorities to agent {agent_id}\")\n        return False\n\ndef update_mode_tracking(meta_agent_id, agent_id, mode_id):\n    \"\"\"Update the tracking data with the new mode\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get current tracking data\n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/tracking\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(f\"Failed to retrieve tracking data\")\n        return False\n    \n    tracking_data = json.loads(response.json()[\"content\"])\n    \n    # Update the agent's current mode\n    if agent_id in tracking_data[\"monitored_agents\"]:\n        previous_mode = tracking_data[\"monitored_agents\"][agent_id][\"current_mode\"]\n        tracking_data[\"monitored_agents\"][agent_id][\"current_mode\"] = mode_id\n        tracking_data[\"monitored_agents\"][agent_id][\"last_mode_change\"] = datetime.now().isoformat()\n        \n        # Add to mode history\n        tracking_data[\"monitored_agents\"][agent_id][\"mode_history\"].append({\n            \"from\": previous_mode,\n            \"to\": mode_id,\n            \"timestamp\": datetime.now().isoformat()\n        })\n        \n        # Add to global mode changes list\n        tracking_data[\"mode_changes\"].append({\n            \"agent_id\": agent_id,\n            \"from\": previous_mode,\n            \"to\": mode_id,\n            \"timestamp\": datetime.now().isoformat()\n        })\n        \n        # Update tracking data\n        response = requests.put(\n            f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/tracking\",\n            headers=headers,\n            json={\"content\": json.dumps(tracking_data, indent=2)}\n        )\n        \n        if response.status_code == 200:\n            print(f\"Tracking data updated for agent {agent_id}: {previous_mode} -&gt; {mode_id}\")\n            return True\n        else:\n            print(f\"Failed to update tracking data for agent {agent_id}\")\n            return False\n    else:\n        print(f\"Agent {agent_id} not found in monitored agents\")\n        return False\n\ndef notify_agent_of_mode_change(meta_agent_id, agent_id, mode_id, mode_name, mode_description):\n    \"\"\"Notify the agent of a mode change\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Send a message to the agent\n    message = f\"Mode changed to {mode_name} ({mode_id}). {mode_description}\"\n    \n    response = requests.post(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/messages\",\n        headers=headers,\n        json={\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"send_message_to_agent_async(agent_id='{agent_id}', message='{message}')\"\n                }\n            ]\n        }\n    )\n    \n    if response.status_code == 200:\n        print(f\"Notification sent to agent {agent_id}\")\n        return True\n    else:\n        print(f\"Failed to send notification to agent {agent_id}\")\n        return False\n</code></pre>\n<h2 id=\"bkmrk-main-check-function\">Main Check Function</h2>\n<p id=\"bkmrk-finally%2C-we-need-a-m\">Finally, we need a main function that the Meta-Agent will execute when triggered to check all monitored agents:</p>\n<pre id=\"bkmrk-def-check_all_agents\"><code class=\"language-python\">def check_all_agents(meta_agent_id):\n    \"\"\"Check all monitored agents for potential mode changes\"\"\"\n    \n    # Get tracking data to find monitored agents\n    tracking_data = get_tracking_data(meta_agent_id)\n    monitored_agents = tracking_data.get(\"monitored_agents\", {})\n    \n    # Get available modes\n    modes_repo = get_modes_repository(meta_agent_id)\n    available_modes = modes_repo.get(\"available_modes\", [])\n    \n    results = {}\n    \n    # Check each agent\n    for agent_id in monitored_agents.keys():\n        print(f\"Checking agent {agent_id}...\")\n        \n        # Analyze conversation\n        analysis, messages = analyze_conversation(agent_id, meta_agent_id)\n        if not analysis:\n            results[agent_id] = {\"status\": \"error\", \"message\": \"Failed to analyze conversation\"}\n            continue\n        \n        # Select optimal mode\n        optimal_mode = select_optimal_mode(analysis, available_modes)\n        current_mode = monitored_agents[agent_id][\"current_mode\"]\n        \n        # If mode change is needed, apply it\n        if optimal_mode != current_mode:\n            print(f\"Mode change needed for agent {agent_id}: {current_mode} -&gt; {optimal_mode}\")\n            success = apply_mode_configuration(agent_id, meta_agent_id, optimal_mode)\n            \n            if success:\n                results[agent_id] = {\n                    \"status\": \"changed\",\n                    \"from\": current_mode,\n                    \"to\": optimal_mode,\n                    \"analysis\": analysis\n                }\n            else:\n                results[agent_id] = {\n                    \"status\": \"error\",\n                    \"message\": f\"Failed to apply mode {optimal_mode}\",\n                    \"analysis\": analysis\n                }\n        else:\n            print(f\"No mode change needed for agent {agent_id} (current: {current_mode})\")\n            results[agent_id] = {\n                \"status\": \"unchanged\",\n                \"mode\": current_mode,\n                \"analysis\": analysis\n            }\n    \n    # Log the check results\n    log_check_results(meta_agent_id, results)\n    \n    return results\n\ndef log_check_results(meta_agent_id, results):\n    \"\"\"Log the results of an agent check\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Create a summary of the results\n    summary = {\n        \"timestamp\": datetime.now().isoformat(),\n        \"agents_checked\": len(results),\n        \"mode_changes\": sum(1 for r in results.values() if r.get(\"status\") == \"changed\"),\n        \"errors\": sum(1 for r in results.values() if r.get(\"status\") == \"error\"),\n        \"details\": results\n    }\n    \n    # Log to archival memory\n    response = requests.post(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/archival-memory\",\n        headers=headers,\n        json={\"text\": f\"Agent Check Results: {json.dumps(summary, indent=2)}\"}\n    )\n    \n    if response.status_code == 200:\n        print(f\"Check results logged to archival memory\")\n        return True\n    else:\n        print(f\"Failed to log check results\")\n        return False\n</code></pre>\n<p id=\"bkmrk-this-implementation-\">This implementation provides a comprehensive framework for analyzing conversations, selecting appropriate modes, and applying configuration updates to agents. The system is designed to be conservative in making changes to prevent mode thrashing while still being responsive to explicit user requests and significant shifts in conversation patterns.</p>\n",
  "tags": [],
  "book": "Letta Meta-Agent System: Design & Implementation Guide",
  "chapter": ""
}