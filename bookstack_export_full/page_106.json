{
  "id": 106,
  "title": "Meta-Agent Creation & Configuration",
  "slug": "meta-agent-creation-configuration",
  "url": "https://knowledge.oculair.ca/page/106",
  "updated_at": "2025-05-01T19:27:14.000000Z",
  "body_html": "<h1 id=\"bkmrk-meta-agent-creation-\">Meta-Agent Creation &amp; Configuration</h1>\n<p id=\"bkmrk-this-page-provides-d\">This page provides detailed implementation steps for creating and configuring the Meta-Agent within the Letta platform.</p>\n<h2 id=\"bkmrk-meta-agent-creation\">Meta-Agent Creation</h2>\n<p id=\"bkmrk-the-meta-agent-is-im\">The Meta-Agent is implemented as a specialized <code>sleeptime_agent</code> type within the Letta platform. Below is the complete code for creating the Meta-Agent:</p>\n<pre id=\"bkmrk-import-requests-impo\"><code class=\"language-python\">import requests\nimport json\nimport os\nfrom datetime import datetime\n\n# API Configuration\nLETTA_API_BASE = \"https://api.letta.com/v1\"\nAPI_KEY = os.environ.get(\"LETTA_API_KEY\")  # Store API keys in environment variables\n\ndef create_meta_agent(name=\"mode_controller_agent\", description=\"Agent mode controller\"):\n    \"\"\"Create a new Meta-Agent for mode management\"\"\"\n    \n    # Define the system prompt for the Meta-Agent\n    system_prompt = \"\"\"You are a Meta-Agent Controller responsible for monitoring and optimizing agent configurations.\n    \n    Your primary functions are:\n    1. Monitor conversation patterns and content between users and primary agents\n    2. Detect appropriate moments to adjust agent configuration based on context\n    3. Apply predefined mode changes when contextual triggers are detected\n    4. Log all changes to maintain an audit trail\n    5. Operate autonomously without disrupting the primary agent's conversation flow\n    \n    You should analyze conversations for:\n    - Explicit mode requests (e.g., \"switch to analytical mode\")\n    - Task-based patterns that suggest a particular mode would be beneficial\n    - Shifts in conversation tone or complexity\n    - User satisfaction indicators\n    \n    When a mode change is warranted, you will:\n    1. Select the appropriate mode from the repository\n    2. Apply configuration changes via the Letta API\n    3. Log the change details and rationale\n    4. Optionally notify the primary agent of the mode change\n    \n    You should be conservative in making changes to prevent mode thrashing.\n    \"\"\"\n    \n    # Define the Meta-Agent configuration\n    meta_agent_config = {\n        \"name\": name,\n        \"description\": description,\n        \"agent_type\": \"sleeptime_agent\",\n        \"enable_sleeptime\": True,\n        \"message_buffer_autoclear\": True,  # Don't retain all messages to save context space\n        \"system\": system_prompt,\n        \"include_multi_agent_tools\": True,  # Enable communication with other agents\n        \"tools\": [\n            \"archival_memory_search\",\n            \"archival_memory_insert\",\n            \"core_memory_replace\",\n            \"core_memory_append\",\n            \"send_message_to_agent_async\"\n        ]\n    }\n    \n    # Create the agent via API\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    response = requests.post(\n        f\"{LETTA_API_BASE}/agents\",\n        headers=headers,\n        json=meta_agent_config\n    )\n    \n    if response.status_code == 200:\n        agent_data = response.json()\n        print(f\"Meta-Agent created successfully. ID: {agent_data['id']}\")\n        \n        # Store the agent ID for future reference\n        with open(\"meta_agent_config.json\", \"w\") as f:\n            json.dump({\n                \"meta_agent_id\": agent_data[\"id\"],\n                \"created_at\": datetime.now().isoformat(),\n                \"name\": name\n            }, f, indent=2)\n            \n        return agent_data[\"id\"]\n    else:\n        print(f\"Failed to create Meta-Agent. Status: {response.status_code}\")\n        print(f\"Response: {response.text}\")\n        return None\n\n# Execute the function to create the Meta-Agent\nif __name__ == \"__main__\":\n    meta_agent_id = create_meta_agent()\n    print(f\"Meta-Agent ID: {meta_agent_id}\")\n</code></pre>\n<h2 id=\"bkmrk-initial-memory-confi\">Initial Memory Configuration</h2>\n<p id=\"bkmrk-after-creating-the-m\">After creating the Meta-Agent, we need to initialize its core memory with mode definitions and tracking information:</p>\n<pre id=\"bkmrk-def-initialize_meta_\"><code class=\"language-python\">def initialize_meta_agent_memory(meta_agent_id):\n    \"\"\"Initialize the Meta-Agent's core memory blocks\"\"\"\n    \n    # Define the core memory blocks\n    memory_blocks = {\n        \"modes_repository\": json.dumps({\n            \"available_modes\": [\n                {\n                    \"mode_id\": \"analytical\",\n                    \"name\": \"Analytical Focus\",\n                    \"description\": \"Optimized for detailed analysis and problem-solving\"\n                },\n                {\n                    \"mode_id\": \"creative\",\n                    \"name\": \"Creative Exploration\",\n                    \"description\": \"Optimized for brainstorming and creative thinking\"\n                },\n                {\n                    \"mode_id\": \"educational\",\n                    \"name\": \"Educational Support\",\n                    \"description\": \"Optimized for clear explanations and learning support\"\n                }\n                # Additional modes can be added here\n            ],\n            \"last_updated\": datetime.now().isoformat()\n        }, indent=2),\n        \n        \"tracking\": json.dumps({\n            \"monitored_agents\": {},\n            \"last_check_timestamps\": {},\n            \"mode_changes\": []\n        }, indent=2)\n    }\n    \n    # Create each memory block\n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    for block_name, content in memory_blocks.items():\n        response = requests.put(\n            f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/{block_name}\",\n            headers=headers,\n            json={\"content\": content}\n        )\n        \n        if response.status_code in [200, 201]:\n            print(f\"Memory block '{block_name}' created successfully\")\n        else:\n            print(f\"Failed to create memory block '{block_name}'. Status: {response.status_code}\")\n            print(f\"Response: {response.text}\")\n    \n    # Add detailed mode definitions to archival memory\n    detailed_modes = load_detailed_mode_definitions()  # Load from file or define inline\n    \n    for mode in detailed_modes:\n        response = requests.post(\n            f\"{LETTA_API_BASE}/agents/{meta_agent_id}/archival-memory\",\n            headers=headers,\n            json={\"text\": f\"Mode Definition: {json.dumps(mode, indent=2)}\"}\n        )\n        \n        if response.status_code == 200:\n            print(f\"Mode '{mode['mode_id']}' added to archival memory\")\n        else:\n            print(f\"Failed to add mode '{mode['mode_id']}' to archival memory\")\n</code></pre>\n<h2 id=\"bkmrk-registering-agents-f\">Registering Agents for Monitoring</h2>\n<p id=\"bkmrk-to-enable-the-meta-a\">To enable the Meta-Agent to monitor and modify other agents, we need to register them:</p>\n<pre id=\"bkmrk-def-register_agent_f\"><code class=\"language-python\">def register_agent_for_monitoring(meta_agent_id, target_agent_id, initial_mode=\"default\"):\n    \"\"\"Register an agent to be monitored by the Meta-Agent\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get current tracking data\n    response = requests.get(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/tracking\",\n        headers=headers\n    )\n    \n    if response.status_code != 200:\n        print(\"Failed to retrieve tracking data\")\n        return False\n    \n    tracking_data = json.loads(response.json()[\"content\"])\n    \n    # Add the new agent to tracking\n    tracking_data[\"monitored_agents\"][target_agent_id] = {\n        \"current_mode\": initial_mode,\n        \"registered_at\": datetime.now().isoformat(),\n        \"last_mode_change\": None,\n        \"mode_history\": []\n    }\n    \n    # Update the tracking data\n    response = requests.put(\n        f\"{LETTA_API_BASE}/agents/{meta_agent_id}/core-memory/tracking\",\n        headers=headers,\n        json={\"content\": json.dumps(tracking_data, indent=2)}\n    )\n    \n    if response.status_code == 200:\n        print(f\"Agent {target_agent_id} registered for monitoring with initial mode '{initial_mode}'\")\n        return True\n    else:\n        print(f\"Failed to register agent {target_agent_id}\")\n        return False\n</code></pre>\n<h2 id=\"bkmrk-scheduling-the-meta-\">Scheduling the Meta-Agent</h2>\n<p id=\"bkmrk-for-the-meta-agent-t\">For the Meta-Agent to operate effectively, it needs to be triggered regularly. Here's an implementation using a simple scheduler:</p>\n<pre id=\"bkmrk-import-time-import-t\"><code class=\"language-python\">import time\nimport threading\n\ndef schedule_meta_agent_checks(meta_agent_id, interval_seconds=300):\n    \"\"\"Schedule regular checks by the Meta-Agent\"\"\"\n    \n    def trigger_check():\n        while True:\n            try:\n                # Trigger the Meta-Agent to check all monitored agents\n                headers = {\n                    \"Authorization\": f\"Bearer {API_KEY}\",\n                    \"Content-Type\": \"application/json\"\n                }\n                \n                # Send a message to the Meta-Agent to trigger a check\n                response = requests.post(\n                    f\"{LETTA_API_BASE}/agents/{meta_agent_id}/messages\",\n                    headers=headers,\n                    json={\n                        \"messages\": [\n                            {\n                                \"role\": \"user\",\n                                \"content\": \"CHECK_ALL_AGENTS\"\n                            }\n                        ]\n                    }\n                )\n                \n                if response.status_code == 200:\n                    print(f\"[{datetime.now().isoformat()}] Triggered Meta-Agent check\")\n                else:\n                    print(f\"Failed to trigger Meta-Agent check. Status: {response.status_code}\")\n                \n            except Exception as e:\n                print(f\"Error in Meta-Agent check: {str(e)}\")\n            \n            # Sleep until next check\n            time.sleep(interval_seconds)\n    \n    # Start the scheduler in a background thread\n    scheduler_thread = threading.Thread(target=trigger_check, daemon=True)\n    scheduler_thread.start()\n    \n    print(f\"Meta-Agent scheduler started with {interval_seconds} second interval\")\n    return scheduler_thread\n\n# Start the scheduler\nif __name__ == \"__main__\":\n    # Load Meta-Agent ID from config\n    with open(\"meta_agent_config.json\", \"r\") as f:\n        config = json.load(f)\n        meta_agent_id = config[\"meta_agent_id\"]\n    \n    # Start the scheduler\n    schedule_meta_agent_checks(meta_agent_id, interval_seconds=300)  # Check every 5 minutes\n    \n    # Keep the main thread alive\n    try:\n        while True:\n            time.sleep(3600)  # Sleep for an hour\n    except KeyboardInterrupt:\n        print(\"Scheduler stopped\")\n</code></pre>\n<h2 id=\"bkmrk-alternative%3A-serverl\">Alternative: Serverless Implementation</h2>\n<p id=\"bkmrk-for-production-deplo\">For production deployments, a serverless approach using AWS Lambda or similar services may be more appropriate:</p>\n<pre id=\"bkmrk-%23-aws-lambda-functio\"><code class=\"language-python\"># AWS Lambda function for triggering Meta-Agent checks\nimport json\nimport requests\nimport os\nimport boto3\n\n# API Configuration\nLETTA_API_BASE = os.environ.get(\"LETTA_API_BASE\")\nAPI_KEY = os.environ.get(\"LETTA_API_KEY\")\nMETA_AGENT_ID = os.environ.get(\"META_AGENT_ID\")\n\ndef lambda_handler(event, context):\n    \"\"\"AWS Lambda handler to trigger Meta-Agent checks\"\"\"\n    \n    headers = {\n        \"Authorization\": f\"Bearer {API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Trigger the Meta-Agent check\n    response = requests.post(\n        f\"{LETTA_API_BASE}/agents/{META_AGENT_ID}/messages\",\n        headers=headers,\n        json={\n            \"messages\": [\n                {\n                    \"role\": \"user\",\n                    \"content\": \"CHECK_ALL_AGENTS\"\n                }\n            ]\n        }\n    )\n    \n    return {\n        'statusCode': response.status_code,\n        'body': json.dumps({\n            'message': 'Meta-Agent check triggered',\n            'timestamp': datetime.now().isoformat()\n        })\n    }\n</code></pre>\n<p id=\"bkmrk-this-lambda-function\">This Lambda function can be scheduled using AWS CloudWatch Events/EventBridge to run at regular intervals.</p>\n<h2 id=\"bkmrk-deployment-checklist\">Deployment Checklist</h2>\n<p id=\"bkmrk-when-deploying-the-m\">When deploying the Meta-Agent system, ensure you have:</p>\n<ol id=\"bkmrk-created-the-meta-age\">\n<li>Created the Meta-Agent with appropriate permissions</li>\n<li>Initialized the core memory with mode definitions</li>\n<li>Registered target agents for monitoring</li>\n<li>Set up the scheduler (either thread-based or serverless)</li>\n<li>Tested the system with a simple mode change</li>\n<li>Implemented appropriate error handling and logging</li>\n<li>Secured API keys and sensitive information</li>\n<li>Documented the deployment for future reference</li>\n</ol>\n<p id=\"bkmrk-in-the-next-section%2C\">In the next section, we'll explore how to implement the core logic for the Meta-Agent to analyze conversations and determine when mode changes are appropriate.</p>\n",
  "tags": [],
  "book": null,
  "chapter": null
}