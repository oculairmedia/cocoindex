{
  "id": 90,
  "title": "Simple Direct Tool Selection",
  "slug": "simple-direct-tool-selection",
  "url": "https://knowledge.oculair.ca/books/unknown/page/simple-direct-tool-selection",
  "updated_at": "2025-04-12T22:24:54.000000Z",
  "body_html": "<h1 id=\"bkmrk-simple-direct-tool-s\">Simple Direct Tool Selection with Small LLM</h1>\n<p id=\"bkmrk-this-document-outlin\">This document outlines the simplest approach to implementing dynamic tool loading for Letta agents when managing hundreds of tools.</p>\n<h2 id=\"bkmrk-overview\">Overview</h2>\n<p id=\"bkmrk-this-approach-uses-a\">This approach uses a small language model to select relevant tools from a large collection based on the user query. The selected tools are then attached to the Letta agent, which handles the actual tool usage.</p>\n<h2 id=\"bkmrk-implementation-flow\">Implementation Flow</h2>\n<ol id=\"bkmrk-receive-user-query-u\">\n<li>Receive user query</li>\n<li>Use a small LLM to analyze the query and select relevant tools</li>\n<li>Attach selected tools to the Letta agent</li>\n<li>Maintain previously used tools for context continuity</li>\n<li>Let Letta handle tool execution with its standard function calling capability</li>\n</ol>\n<h2 id=\"bkmrk-code-implementation\">Code Implementation</h2>\n<pre id=\"bkmrk-def-select_relevant_\"><code class=\"language-python\">def select_relevant_tools(query, all_tools, previous_tools=None, model=\"command-r7b\"):\n    # Create a concise description of each tool\n    tool_descriptions = [f\"ID: {tool.id}, Name: {tool.name}, Description: {tool.description}\" \n                         for tool in all_tools]\n    \n    # Create prompt for the small model\n    prompt = f\"\"\"\n    Query: {query}\n    \n    Available Tools:\n    {'\\n'.join(tool_descriptions)}\n    \n    Previously Used Tools: {', '.join([tool.id for tool in (previous_tools or [])])}\n    \n    Select the tool IDs that would be most helpful for answering this query.\n    Return only the relevant tool IDs as a comma-separated list.\n    \"\"\"\n    \n    # Use small model to select tools\n    small_model = get_model(model)\n    selected_tool_ids = small_model.generate(prompt).strip()\n    \n    # Parse response and retrieve tool objects\n    tool_ids = [id.strip() for id in selected_tool_ids.split(',')]\n    selected_tools = [tool for tool in all_tools if tool.id in tool_ids]\n    \n    # Include previously used tools for continuity\n    if previous_tools:\n        selected_tools = list(set(selected_tools + previous_tools))\n    \n    return selected_tools\n\ndef handle_query(query, previous_tools=None):\n    # Step 1: Select relevant tools using small model\n    relevant_tools = select_relevant_tools(query, all_tools, previous_tools)\n    \n    # Step 2: Attach tools to Letta agent\n    agent = attach_tools_to_agent(\"your-letta-agent-id\", relevant_tools)\n    \n    # Step 3: Let agent handle the query with available tools\n    response = prompt_agent(agent.id, query)\n    \n    return response, relevant_tools  # Return tools for next query\n</code></pre>\n<h2 id=\"bkmrk-recommended-small-mo\">Recommended Small Models</h2>\n<p id=\"bkmrk-several-efficient-mo\">Several efficient models work well for this task:</p>\n<ol id=\"bkmrk-command-r7b---cohere\">\n<li><strong>Command R7B</strong> - Cohere's small, specialized model for RAG and tool routing</li>\n<li><strong>Mistral 7B Function Calling</strong> - Good balance of size and capability</li>\n<li><strong>Llama 3 8B Instruct</strong> - Strong tool understanding in a compact size</li>\n</ol>\n<h2 id=\"bkmrk-advantages\">Advantages</h2>\n<ul id=\"bkmrk-simplicity%3A-straight\">\n<li><strong>Simplicity</strong>: Straightforward implementation with minimal components</li>\n<li><strong>Efficiency</strong>: Small models are fast and cost-effective for tool selection</li>\n<li><strong>Maintainability</strong>: Clear separation of concerns between tool selection and execution</li>\n<li><strong>Context Awareness</strong>: Preserves continuity by considering previously used tools</li>\n</ul>\n<h2 id=\"bkmrk-limitations\">Limitations</h2>\n<ul id=\"bkmrk-as-tool-count-grows-\">\n<li>As tool count grows very large (thousands), the prompt may become unwieldy</li>\n<li>Selection accuracy depends on the quality of tool descriptions</li>\n<li>May select too many or too few tools without fine-tuning</li>\n</ul>\n<h2 id=\"bkmrk-implementation-consi\">Implementation Considerations</h2>\n<ol id=\"bkmrk-tool-descriptions%3A-k\">\n<li><strong>Tool Descriptions</strong>: Keep descriptions concise but informative</li>\n<li><strong>Model Selection</strong>: Choose a small model that excels at classification tasks</li>\n<li><strong>Filtering</strong>: Consider adding a maximum tool count to prevent overloading</li>\n<li><strong>Caching</strong>: Cache tool selection results for similar queries to improve performance</li>\n</ol>\n<p id=\"bkmrk-this-approach-provid\">This approach provides a balanced solution for dynamic tool loading that is simple to implement while still being efficient and effective.</p>\n",
  "tags": [],
  "book": "Unknown",
  "chapter": ""
}