{
  "id": 95,
  "title": "Proof of concept of dynamic tool search using letta as it's own dependency",
  "slug": "proof-of-concept-of-dynamic-tool-search-using-letta-as-its-own-dependency",
  "url": "https://knowledge.oculair.ca/page/95",
  "updated_at": "2025-04-15T17:18:42.000000Z",
  "body_html": "<p id=\"bkmrk-tool_finder_agent.py\"><a href=\"https://knowledge.oculair.ca/attachments/1\" target=\"_blank\" rel=\"noopener\">tool_finder_agent.py</a></p>\r\n<p id=\"bkmrk-attach_tools_from_qu\"><a href=\"https://knowledge.oculair.ca/attachments/2\" target=\"_blank\" rel=\"noopener\">attach_tools_from_query.py</a></p>\r\n<pre class=\"sc-cGXZpB XZELl\" id=\"bkmrk-%23-methodology%3A-letta-1\"><code class=\"language-markdown\"># Methodology: Letta Tool Finding and Attachment System\r\n\r\n## 1. Introduction\r\n\r\nThis document outlines the methodology employed by a system designed to dynamically find relevant Letta tools based on natural language queries and attach them to specified target agents. The system consists of two primary Python scripts:\r\n\r\n1.  **`tool_finder_agent.py`**: Responsible for setting up and managing a specialized \"Tool Finder Agent\" within the Letta environment. This agent possesses knowledge of available tools and the logic to recommend them.\r\n2.  **`attach_tools_from_query.py`**: Implements a Letta *tool* function (`find_and_attach_recommended_tools`) that orchestrates the process of querying the Tool Finder Agent and attaching the recommended tools to a target agent.\r\n\r\nThe core idea is to leverage a dedicated agent with searchable knowledge of the tool ecosystem to provide dynamic tool recommendations, which can then be automatically integrated into other agents' capabilities.\r\n\r\n## 2. System Components and Setup (`tool_finder_agent.py`)\r\n\r\nThis script handles the initialization and maintenance of the core \"Tool Finder Agent\".\r\n\r\n**2.1. Agent Creation/Retrieval:**\r\n*   The script first checks if an agent with the predefined name (`Tool Finder Agent`) already exists using `get_agent_by_name`.\r\n*   If it exists, its ID is retrieved.\r\n*   If not, a new agent is created using `create_agent` with specific configurations (LLM model, embedding model, description).\r\n\r\n**2.2. Knowledge Population - System Instructions:**\r\n*   A detailed set of system instructions outlining the agent's purpose and step-by-step process for handling queries is defined.\r\n*   This instruction set is stored in a Letta Memory Block (created or retrieved using `get_or_create_memory_block` with the label \"system\").\r\n*   This memory block is attached to the Tool Finder Agent's core memory using `attach_memory_block_to_agent`, guiding its behavior.\r\n\r\n**2.3. Knowledge Population - Tool Data:**\r\n*   The script fetches *all* available tools from the Letta system, including both native tools and tools available via connected MCP servers, using the `list_all_tools` function (which handles pagination across different API endpoints).\r\n*   For each tool, relevant information (name, ID, description, source type, server name for MCP tools, input schema, examples) is extracted and formatted into a descriptive text passage. Keywords and domain tags are added to enhance searchability.\r\n*   These formatted tool passages are uploaded into the Tool Finder Agent's *archival memory* using `upload_tools_to_archival_memory`. This function checks for existing passages for each tool to avoid duplicates and uses parallel processing (`ThreadPoolExecutor`) for efficiency. This archival memory serves as the searchable knowledge base for the agent.\r\n\r\n## 3. Runtime Operation: Tool Recommendation and Attachment (`attach_tools_from_query.py`)\r\n\r\nThis script defines the `find_and_attach_recommended_tools` function, intended to be used as a Letta tool itself.\r\n\r\n**3.1. Invocation:**\r\n*   An external process (e.g., another agent, a workflow) calls the `find_and_attach_recommended_tools` tool.\r\n*   Required arguments:\r\n    *   `finder_agent_id`: The ID of the Tool Finder Agent created in the setup phase.\r\n    *   `target_agent_id`: The ID of the agent to which the recommended tools should be attached.\r\n    *   `query`: The natural language query describing the desired tool functionality.\r\n\r\n**3.2. Querying the Finder Agent:**\r\n*   The function formats the user's `query` into a more detailed prompt, explicitly requesting the Finder Agent to follow its system instructions (analyze intent, search archival memory, return structured JSON).\r\n*   It sends this enhanced prompt to the `finder_agent_id` using the `prompt_agent` function (which prefers the streaming API endpoint for potentially faster responses).\r\n\r\n**3.3. Processing the Response:**\r\n*   The Tool Finder Agent, guided by its system instructions and searchable archival memory, processes the query and returns a response containing recommended tools in the specified JSON format.\r\n*   The `find_and_attach_recommended_tools` function receives this response.\r\n*   It extracts the list of recommended tools and their IDs from the JSON payload using `extract_tool_ids`.\r\n\r\n**3.4. Tool Registration (MCP Tools):**\r\n*   The script iterates through the extracted tool IDs.\r\n*   It checks if an ID represents an unregistered MCP tool (heuristic: contains \"__\" and doesn't start with \"tool-\").\r\n*   If an unregistered MCP tool is detected (e.g., `bookstack__create_page`), it calls the `register_mcp_tool` function. This function interacts with the Letta API (`POST /v1/tools/mcp/servers/{server}/{tool}`) to register the tool and obtain its official Letta tool ID (e.g., `tool-xxxxxxxx`). It includes fallback logic to find the ID if the tool was already registered but the initial call failed (e.g., due to a 409 Conflict).\r\n\r\n**3.5. Tool Attachment:**\r\n*   A final list of attachable tool IDs (original native IDs and newly registered/found MCP tool IDs) is compiled, removing duplicates.\r\n*   The script uses `aiohttp` and `asyncio` to concurrently attempt to attach each tool ID to the `target_agent_id` via the Letta API (`PATCH /v1/agents/{agent_id}/tools/attach/{tool_id}`).\r\n*   The results of each attachment attempt (success or failure, with error messages) are collected.\r\n\r\n**3.6. Reporting:**\r\n*   The function returns a JSON summary detailing the outcome of the operation, including:\r\n    *   Overall success status.\r\n    *   Counts of processed, successfully attached, and failed tools.\r\n    *   Lists of successfully attached tool IDs and details of any failures.\r\n\r\n## 4. Key Supporting Functions &amp; Logic\r\n\r\n*   **API Interaction (`make_api_request`)**: A robust function handles all HTTP requests to the Letta API, including setting appropriate headers (auth), handling JSON data, supporting streaming responses, and implementing retry logic for transient errors (like 404s).\r\n*   **Memory Management**: Functions exist to create/retrieve memory blocks (`get_or_create_memory_block`), attach them (`attach_memory_block_to_agent`), create passages in archival memory (`create_passage_in_archival_memory`), and search archival memory (`search_archival_memory`).\r\n*   **Tool Handling**: Functions specifically manage tool listing (`list_all_tools`), MCP tool registration (`register_mcp_tool`), and attachment (`attach_tools_to_agent`, `attach_single_tool`).\r\n*   **Asynchronous Operations**: `asyncio` and `aiohttp` are used in `attach_tools_from_query.py` for concurrent tool attachment, improving performance when multiple tools need to be attached. `concurrent.futures` is used in `tool_finder_agent.py` for parallelizing archival memory uploads.\r\n*   **Error Handling &amp; Logging**: Comprehensive logging is implemented throughout, and functions generally return status indicators or raise exceptions to handle failures gracefully. Debug flags (`DEBUG_MODE`) enable more verbose output.\r\n\r\n## 5. Conclusion\r\n\r\nThis system provides a powerful mechanism for dynamic tool discovery and integration within the Letta platform. By centralizing tool knowledge within a dedicated agent's searchable memory and providing a tool function to query this agent and manage attachments, it allows workflows and other agents to request and acquire necessary capabilities based on high-level natural language descriptions, rather than requiring predefined tool lists.</code></pre>",
  "tags": [],
  "book": null,
  "chapter": null
}